{"ast":null,"code":"var _jsxFileName = \"D:\\\\Repos\\\\lcjs-dashboard\\\\frontend\\\\src\\\\components\\\\charts\\\\SpanChart.jsx\",\n  _s = $RefreshSig$();\nimport { SolidFill, ColorRGBA, AxisTickStrategies, Themes, ColorHEX } from \"@lightningchart/lcjs\";\nimport { useEffect, useState, useContext, useId } from \"react\";\nimport { LCContext } from \"../../LC\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function SpanChart(props) {\n  _s();\n  const data = props.data;\n  // console.log(`SpanChart data`, data);\n  const id = useId();\n  const lc = useContext(LCContext);\n  const [chart, setChart] = useState(undefined);\n\n  // Create chart just once during lifecycle of component.\n  useEffect(() => {\n    const container = document.getElementById(id);\n    if (!container) return;\n    if (!lc) {\n      console.log(\"LC context not ready yet\");\n      return;\n    }\n    const stages = ['light', 'deep', 'rem'];\n\n    // Define an interface for creating span charts\n    let spanChart;\n    // Store the actual chart instance for cleanup\n    let actualChart;\n    // User side SpanChart logic\n    spanChart = () => {\n      // Create a XY-Chart and add a RectSeries to it for rendering rectangles\n      const chart = lc.ChartXY({\n        legend: {\n          visible: false\n        },\n        theme: Themes.cyberSpace,\n        container\n      });\n      chart.setTitle('Sleep Stages (Last Night)').setUserInteractions(undefined).setCursorMode(undefined).setBackgroundFillStyle(new SolidFill({\n        color: ColorHEX('#060316')\n      }));\n\n      // Store the actual chart instance\n      actualChart = chart;\n      const axisX = chart.getDefaultAxisX()\n      // Hide default ticks, instead rely on CustomTicks\n      .setTickStrategy(AxisTickStrategies.Empty);\n      const axisY = chart.getDefaultAxisY()\n      // Hide default ticks, instead rely on CustomTicks\n      .setTickStrategy(AxisTickStrategies.Empty);\n      let y = 0;\n      for (let i = 20; i <= 32; i++) {\n        // Example: show 20h (8 PM) → 32h (8 AM next day)\n        const hour = i % 24;\n        const label = hour.toString().padStart(2, '0') + \":00\";\n        axisX.addCustomTick().setValue(i).setTickLength(4).setGridStrokeLength(0).setTextFormatter(() => label).setMarker(marker => marker.setTextFillStyle(new SolidFill({\n          color: ColorRGBA(170, 170, 170)\n        })));\n      }\n      const figureHeight = 10;\n      const figureThickness = 10;\n      const figureGap = figureThickness * 0.5;\n      const fitAxes = () => {\n        // Custom fitting for some additional margins\n        axisY.setInterval({\n          start: y,\n          end: figureHeight * 0.5,\n          stopAxisAfter: false\n        });\n      };\n      let customYRange = figureHeight + figureGap * 1.6;\n      const addCategory = category => {\n        const categoryY = y;\n        const addSpan = (i, min, max, label) => {\n          // Add rect\n          const rectDimensions = {\n            x: min,\n            y: categoryY - figureHeight,\n            width: max - min,\n            height: figureHeight\n          };\n          if (index !== i) {\n            customYRange = customYRange + figureHeight + 1;\n          }\n          fitAxes();\n          // Return figure\n          const rectSeries = chart.addRectangleSeries().add(rectDimensions).setCornerRadius(10);\n          return rectSeries;\n        };\n\n        // Add custom tick for category\n        axisY.addCustomTick().setValue(y - figureHeight * 0.5).setGridStrokeLength(0).setTextFormatter(_ => category).setMarker(marker => marker.setTextFillStyle(new SolidFill({\n          color: ColorRGBA(170, 170, 170)\n        })));\n        y -= figureHeight * 1.5;\n        fitAxes();\n        // Return interface for category\n        return {\n          addSpan\n        };\n      };\n      // Return interface for span chart\n      return {\n        addCategory\n      };\n    };\n\n    // Use the interface for example\n    let chart = spanChart();\n    const categories = ['Light', 'Deep', 'REM'].map(name => chart.addCategory(name));\n    chart.categories = categories;\n    chart.stageMap = {};\n    chart.rectangleSeries = []; // Track rectangle series for clearing\n    stages.forEach((stage, i) => {\n      chart.stageMap[stage] = i; // e.g. { light:0, deep:1, rem:2 }\n    });\n    const spans = [];\n\n    // let index = 0\n    // spans.forEach((values, i) => {\n    //     values.forEach((value, j) => {\n    //         categories[i].addSpan(i, value[0], value[1])\n    //         index = index + 1\n    //     })\n    // })\n\n    setChart(chart);\n    return () => {\n      // Destroy the actual chart instance when component lifecycle ends\n      if (actualChart) {\n        actualChart.dispose();\n      }\n    };\n  }, [id, lc]);\n\n  // Update data whenever data prop changes\n  useEffect(() => {\n    if (!chart || !data) return;\n    console.log(`SpanChart update, data: `, data);\n\n    // Clear previous rectangle series\n    if (chart.rectangleSeries) {\n      chart.rectangleSeries.forEach(series => {\n        try {\n          series.dispose();\n        } catch (e) {\n          // Series might already be disposed\n        }\n      });\n      chart.rectangleSeries = [];\n    }\n    data.forEach(entry => {\n      const {\n        stage,\n        spans\n      } = entry;\n      if (stage === \"wake\") return; // skip wake in chart\n\n      // find correct category row\n      const idx = chart.stageMap[stage];\n      if (idx === undefined) {\n        console.warn(\"Unknown stage:\", stage);\n        return;\n      }\n      spans.forEach(span => {\n        const rectSeries = chart.categories[idx].addSpan(idx, span[0], span[1]);\n        chart.rectangleSeries.push(rectSeries);\n      });\n    });\n  }, [chart, data]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    id: id,\n    style: {\n      width: \"100%\",\n      height: \"100%\"\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 183,\n    columnNumber: 10\n  }, this);\n}\n_s(SpanChart, \"lPoGF9T2AB4o0eYXL6tWsHPot3c=\", false, function () {\n  return [useId];\n});\n_c = SpanChart;\nvar _c;\n$RefreshReg$(_c, \"SpanChart\");","map":{"version":3,"names":["SolidFill","ColorRGBA","AxisTickStrategies","Themes","ColorHEX","useEffect","useState","useContext","useId","LCContext","jsxDEV","_jsxDEV","SpanChart","props","_s","data","id","lc","chart","setChart","undefined","container","document","getElementById","console","log","stages","spanChart","actualChart","ChartXY","legend","visible","theme","cyberSpace","setTitle","setUserInteractions","setCursorMode","setBackgroundFillStyle","color","axisX","getDefaultAxisX","setTickStrategy","Empty","axisY","getDefaultAxisY","y","i","hour","label","toString","padStart","addCustomTick","setValue","setTickLength","setGridStrokeLength","setTextFormatter","setMarker","marker","setTextFillStyle","figureHeight","figureThickness","figureGap","fitAxes","setInterval","start","end","stopAxisAfter","customYRange","addCategory","category","categoryY","addSpan","min","max","rectDimensions","x","width","height","index","rectSeries","addRectangleSeries","add","setCornerRadius","_","categories","map","name","stageMap","rectangleSeries","forEach","stage","spans","dispose","series","e","entry","idx","warn","span","push","style","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/Repos/lcjs-dashboard/frontend/src/components/charts/SpanChart.jsx"],"sourcesContent":["import { SolidFill, ColorRGBA, AxisTickStrategies, Themes, ColorHEX } from \"@lightningchart/lcjs\";\r\nimport { useEffect, useState, useContext, useId } from \"react\";\r\nimport { LCContext } from \"../../LC\";\r\n\r\nexport default function SpanChart(props) {\r\n  const data = props.data;\r\n  // console.log(`SpanChart data`, data);\r\n  const id = useId();\r\n  const lc = useContext(LCContext);\r\n  const [chart, setChart] = useState(undefined);\r\n\r\n  // Create chart just once during lifecycle of component.\r\n  useEffect(() => {\r\n    const container = document.getElementById(id);\r\n    if (!container) return\r\n    if (!lc) {\r\n      console.log(\"LC context not ready yet\");\r\n      return\r\n    }\r\n\r\n    const stages = ['light', 'deep', 'rem'];\r\n\r\n    // Define an interface for creating span charts\r\n    let spanChart\r\n    // Store the actual chart instance for cleanup\r\n    let actualChart \r\n    // User side SpanChart logic\r\n    spanChart = () => {\r\n        // Create a XY-Chart and add a RectSeries to it for rendering rectangles\r\n        const chart = lc.ChartXY({\r\n                legend: { visible: false },\r\n                theme: Themes.cyberSpace,\r\n                container,\r\n            })\r\n            chart.setTitle('Sleep Stages (Last Night)')\r\n            .setUserInteractions(undefined)\r\n            .setCursorMode(undefined)\r\n            .setBackgroundFillStyle(new SolidFill({ color: ColorHEX('#060316') }));\r\n\r\n        // Store the actual chart instance\r\n        actualChart = chart\r\n\r\n        const axisX = chart\r\n            .getDefaultAxisX()\r\n            // Hide default ticks, instead rely on CustomTicks\r\n            .setTickStrategy(AxisTickStrategies.Empty)\r\n\r\n        const axisY = chart\r\n            .getDefaultAxisY()\r\n            // Hide default ticks, instead rely on CustomTicks\r\n            .setTickStrategy(AxisTickStrategies.Empty)\r\n\r\n        let y = 0\r\n        for (let i = 20; i <= 32; i++) { // Example: show 20h (8 PM) → 32h (8 AM next day)\r\n            const hour = i % 24\r\n            const label = hour.toString().padStart(2, '0') + \":00\"\r\n            axisX\r\n                .addCustomTick()\r\n                .setValue(i)\r\n                .setTickLength(4)\r\n                .setGridStrokeLength(0)\r\n                .setTextFormatter(() => label)\r\n                .setMarker((marker) =>\r\n                    marker.setTextFillStyle(new SolidFill({ color: ColorRGBA(170, 170, 170) }))\r\n                )\r\n        }\r\n\r\n        const figureHeight = 10\r\n        const figureThickness = 10\r\n        const figureGap = figureThickness * 0.5\r\n        const fitAxes = () => {\r\n            // Custom fitting for some additional margins\r\n            axisY.setInterval({ start: y, end: figureHeight * 0.5, stopAxisAfter: false })\r\n        }\r\n\r\n        let customYRange = figureHeight + figureGap * 1.6\r\n        const addCategory = (category) => {\r\n            const categoryY = y\r\n\r\n            const addSpan = (i, min, max, label) => {\r\n                // Add rect\r\n                const rectDimensions = {\r\n                    x: min,\r\n                    y: categoryY - figureHeight,\r\n                    width: max - min,\r\n                    height: figureHeight,\r\n                }\r\n                if (index !== i) {\r\n                    customYRange = customYRange + figureHeight + 1\r\n                }\r\n                fitAxes()\r\n                // Return figure\r\n                const rectSeries = chart.addRectangleSeries().add(rectDimensions).setCornerRadius(10)\r\n                return rectSeries\r\n            }\r\n\r\n            // Add custom tick for category\r\n            axisY\r\n                .addCustomTick()\r\n                .setValue(y - figureHeight * 0.5)\r\n                .setGridStrokeLength(0)\r\n                .setTextFormatter((_) => category)\r\n                .setMarker((marker) => marker.setTextFillStyle(new SolidFill({ color: ColorRGBA(170, 170, 170) })))\r\n            y -= figureHeight * 1.5\r\n\r\n            fitAxes()\r\n            // Return interface for category\r\n            return {\r\n                addSpan,\r\n            }\r\n        }\r\n        // Return interface for span chart\r\n        return {\r\n            addCategory,\r\n        }\r\n      }\r\n\r\n    // Use the interface for example\r\n    let chart = spanChart()\r\n    const categories = ['Light', 'Deep', 'REM'].map((name) => chart.addCategory(name))\r\n    chart.categories = categories\r\n    chart.stageMap = {}\r\n    chart.rectangleSeries = [] // Track rectangle series for clearing\r\n    stages.forEach((stage, i) => {\r\n    chart.stageMap[stage] = i   // e.g. { light:0, deep:1, rem:2 }\r\n    })\r\n    const spans = []\r\n\r\n    // let index = 0\r\n    // spans.forEach((values, i) => {\r\n    //     values.forEach((value, j) => {\r\n    //         categories[i].addSpan(i, value[0], value[1])\r\n    //         index = index + 1\r\n    //     })\r\n    // })\r\n    \r\n    setChart(chart);\r\n\r\n    return () => {\r\n      // Destroy the actual chart instance when component lifecycle ends\r\n      if (actualChart) {\r\n        actualChart.dispose();\r\n      }\r\n    };\r\n  }, [id, lc]); \r\n\r\n  // Update data whenever data prop changes\r\n  useEffect(() => {\r\n    if (!chart || !data) return\r\n    \r\n    console.log(`SpanChart update, data: `, data);\r\n\r\n    // Clear previous rectangle series\r\n    if (chart.rectangleSeries) {\r\n      chart.rectangleSeries.forEach(series => {\r\n        try {\r\n          series.dispose();\r\n        } catch (e) {\r\n          // Series might already be disposed\r\n        }\r\n      });\r\n      chart.rectangleSeries = [];\r\n    }\r\n\r\n    data.forEach((entry) => {\r\n      const { stage, spans } = entry\r\n      if (stage === \"wake\") return // skip wake in chart\r\n\r\n      // find correct category row\r\n      const idx = chart.stageMap[stage]\r\n      if (idx === undefined) {\r\n        console.warn(\"Unknown stage:\", stage)\r\n        return\r\n      }\r\n\r\n      spans.forEach(span => {\r\n        const rectSeries = chart.categories[idx].addSpan(idx, span[0], span[1])\r\n        chart.rectangleSeries.push(rectSeries)\r\n      })\r\n    })\r\n  }, [chart, data]);\r\n\r\n  return <div id={id} style={{ width: \"100%\", height: \"100%\" }}></div>;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}