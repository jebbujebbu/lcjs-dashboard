{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\jenni.mikkonen\\\\OneDrive - LightningChart Ltd\\\\Repos\\\\lcjs-dashboard\\\\frontend\\\\src\\\\components\\\\charts\\\\SpanChart.jsx\",\n  _s = $RefreshSig$();\nimport { SolidFill, ColorRGBA, AxisTickStrategies, Themes } from \"@lightningchart/lcjs\";\nimport { useEffect, useState, useContext, useId } from \"react\";\nimport { LCContext } from \"../../LC\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function SpanChart(props) {\n  _s();\n  const data = props.data;\n  const title = props.title;\n  // console.log(`SpanChart ${title} data`, data);\n  const id = useId();\n  const lc = useContext(LCContext);\n  const [chart, setChart] = useState(undefined);\n\n  // Create chart just once during lifecycle of component.\n  useEffect(() => {\n    const container = document.getElementById(id);\n    if (!container) return;\n    if (!lc) {\n      console.log(\"LC context not ready yet\");\n      return;\n    }\n    const stages = ['light', 'deep', 'rem'];\n\n    // Define an interface for creating span charts\n    let spanChart;\n    let actualChart; // Store the actual chart instance for cleanup\n    // User side SpanChart logic\n    spanChart = () => {\n      // Create a XY-Chart and add a RectSeries to it for rendering rectangles\n      const chart = lc.ChartXY({\n        legend: {\n          visible: false\n        },\n        theme: Themes.cyberSpace,\n        container\n      });\n      chart.setTitle('').setUserInteractions(undefined).setCursorMode(undefined);\n\n      // Store the actual chart instance\n      actualChart = chart;\n      const axisX = chart.getDefaultAxisX()\n      // Hide default ticks, instead rely on CustomTicks\n      .setTickStrategy(AxisTickStrategies.Empty);\n      const axisY = chart.getDefaultAxisY()\n      // Hide default ticks, instead rely on CustomTicks\n      .setTickStrategy(AxisTickStrategies.Empty);\n      let y = 0;\n      for (let i = 20; i <= 32; i++) {\n        // Example: show 20h (8 PM) â†’ 32h (8 AM next day)\n        const hour = i % 24;\n        const label = hour.toString().padStart(2, '0') + \":00\";\n        axisX.addCustomTick().setValue(i).setTickLength(4).setGridStrokeLength(0).setTextFormatter(() => label).setMarker(marker => marker.setTextFillStyle(new SolidFill({\n          color: ColorRGBA(170, 170, 170)\n        })));\n      }\n      const figureHeight = 10;\n      const figureThickness = 10;\n      const figureGap = figureThickness * 0.5;\n      const fitAxes = () => {\n        // Custom fitting for some additional margins\n        axisY.setInterval({\n          start: y,\n          end: figureHeight * 0.5,\n          stopAxisAfter: false\n        });\n      };\n      let customYRange = figureHeight + figureGap * 1.6;\n      const addCategory = category => {\n        const categoryY = y;\n        const addSpan = (i, min, max, label) => {\n          // Add rect\n          const rectDimensions = {\n            x: min,\n            y: categoryY - figureHeight,\n            width: max - min,\n            height: figureHeight\n          };\n          // Add element for span labels\n          // const spanText = chart\n          //     .addUIElement(UILayoutBuilders.Row, { x: axisX, y: axisY })\n          //     .setOrigin(UIOrigins.Center)\n          //     .setDraggingMode(UIDraggingModes.notDraggable)\n          //     .setPosition({\n          //         x: (min + max) / 2,\n          //         y: rectDimensions.y + 5,\n          //     })\n          //     .setBackground((background) => background.setFillStyle(emptyFill).setStrokeStyle(emptyLine))\n\n          // spanText.addElement(\n          //     UIElementBuilders.TextBox.addStyler((textBox) =>\n          //         textBox\n          //             .setTextFont((fontSettings) => fontSettings.setSize(13))\n          //             .setText(label)\n          //             .setTextFillStyle(new SolidFill().setColor(ColorRGBA(255, 255, 255))),\n          //     ),\n          // )\n          if (index !== i) {\n            customYRange = customYRange + figureHeight + 1;\n          }\n          fitAxes();\n          // Return figure\n          return chart.addRectangleSeries().add(rectDimensions).setCornerRadius(10);\n        };\n\n        // Add custom tick for category\n        axisY.addCustomTick().setValue(y - figureHeight * 0.5).setGridStrokeLength(0).setTextFormatter(_ => category).setMarker(marker => marker.setTextFillStyle(new SolidFill({\n          color: ColorRGBA(170, 170, 170)\n        })));\n        y -= figureHeight * 1.5;\n        fitAxes();\n        // Return interface for category\n        return {\n          addSpan\n        };\n      };\n      // Return interface for span chart\n      return {\n        addCategory\n      };\n    };\n\n    // Use the interface for example\n    let chart = spanChart();\n    const categories = ['Light', 'Deep', 'REM'].map(name => chart.addCategory(name));\n    chart.categories = categories;\n    chart.stageMap = {};\n    stages.forEach((stage, i) => {\n      chart.stageMap[stage] = i; // e.g. { light:0, deep:1, rem:2 }\n    });\n    const spans = [];\n    let index = 0;\n    spans.forEach((values, i) => {\n      values.forEach((value, j) => {\n        categories[i].addSpan(i, value[0], value[1]);\n        // index = index + 1\n      });\n    });\n    setChart(chart);\n    return () => {\n      // Destroy the actual chart instance when component lifecycle ends\n      if (actualChart) {\n        actualChart.dispose();\n      }\n    };\n  }, [id, lc]);\n\n  // Update data whenever data prop changes\n  useEffect(() => {\n    if (!chart || !data) return;\n    console.log(`SpanChart update, data: `, data);\n\n    // Clear previous rectangles\n    if (chart.rectangles) {\n      chart.rectangles.forEach(rect => {\n        try {\n          rect.dispose();\n        } catch (e) {\n          // Rectangle might already be disposed\n        }\n      });\n      chart.rectangles = [];\n    }\n    data.forEach(entry => {\n      const {\n        stage,\n        spans\n      } = entry;\n      if (stage === \"wake\") return; // skip wake in chart\n\n      // find correct category row\n      const idx = chart.stageMap[stage];\n      if (idx === undefined) {\n        console.warn(\"Unknown stage:\", stage);\n        return;\n      }\n      spans.forEach(span => {\n        const rect = chart.categories[idx].addSpan(idx, span[0], span[1]);\n        chart.rectangles.push(rect);\n      });\n    });\n  }, [chart, data]);\n\n  // Whenever props.title changes, it is reapplied to existing chart without recreating it\n  useEffect(() => {\n    if (!chart) return;\n    chart.setTitle(title);\n  }, [chart, title]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    id: id,\n    style: {\n      width: \"100%\",\n      height: \"100%\"\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 205,\n    columnNumber: 10\n  }, this);\n}\n_s(SpanChart, \"bWzMBqPhS5DHL5ZWPWNtUq2+kHQ=\", false, function () {\n  return [useId];\n});\n_c = SpanChart;\nvar _c;\n$RefreshReg$(_c, \"SpanChart\");","map":{"version":3,"names":["SolidFill","ColorRGBA","AxisTickStrategies","Themes","useEffect","useState","useContext","useId","LCContext","jsxDEV","_jsxDEV","SpanChart","props","_s","data","title","id","lc","chart","setChart","undefined","container","document","getElementById","console","log","stages","spanChart","actualChart","ChartXY","legend","visible","theme","cyberSpace","setTitle","setUserInteractions","setCursorMode","axisX","getDefaultAxisX","setTickStrategy","Empty","axisY","getDefaultAxisY","y","i","hour","label","toString","padStart","addCustomTick","setValue","setTickLength","setGridStrokeLength","setTextFormatter","setMarker","marker","setTextFillStyle","color","figureHeight","figureThickness","figureGap","fitAxes","setInterval","start","end","stopAxisAfter","customYRange","addCategory","category","categoryY","addSpan","min","max","rectDimensions","x","width","height","index","addRectangleSeries","add","setCornerRadius","_","categories","map","name","stageMap","forEach","stage","spans","values","value","j","dispose","rectangles","rect","e","entry","idx","warn","span","push","style","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/jenni.mikkonen/OneDrive - LightningChart Ltd/Repos/lcjs-dashboard/frontend/src/components/charts/SpanChart.jsx"],"sourcesContent":["import { SolidFill, ColorRGBA, AxisTickStrategies, Themes } from \"@lightningchart/lcjs\";\r\nimport { useEffect, useState, useContext, useId } from \"react\";\r\nimport { LCContext } from \"../../LC\";\r\n\r\nexport default function SpanChart(props) {\r\n  const data = props.data;\r\n  const title = props.title;\r\n  // console.log(`SpanChart ${title} data`, data);\r\n  const id = useId();\r\n  const lc = useContext(LCContext);\r\n  const [chart, setChart] = useState(undefined);\r\n\r\n  // Create chart just once during lifecycle of component.\r\n  useEffect(() => {\r\n    const container = document.getElementById(id);\r\n    if (!container) return\r\n    if (!lc) {\r\n      console.log(\"LC context not ready yet\");\r\n      return\r\n    }\r\n\r\n    const stages = ['light', 'deep', 'rem'];\r\n\r\n    // Define an interface for creating span charts\r\n    let spanChart\r\n    let actualChart // Store the actual chart instance for cleanup\r\n    // User side SpanChart logic\r\n    spanChart = () => {\r\n        // Create a XY-Chart and add a RectSeries to it for rendering rectangles\r\n        const chart = lc.ChartXY({\r\n                legend: { visible: false },\r\n                theme: Themes.cyberSpace,\r\n                container,\r\n            })\r\n            chart.setTitle('')\r\n            .setUserInteractions(undefined)\r\n            .setCursorMode(undefined)\r\n\r\n        // Store the actual chart instance\r\n        actualChart = chart\r\n\r\n        const axisX = chart\r\n            .getDefaultAxisX()\r\n            // Hide default ticks, instead rely on CustomTicks\r\n            .setTickStrategy(AxisTickStrategies.Empty)\r\n\r\n        const axisY = chart\r\n            .getDefaultAxisY()\r\n            // Hide default ticks, instead rely on CustomTicks\r\n            .setTickStrategy(AxisTickStrategies.Empty)\r\n\r\n        let y = 0\r\n        for (let i = 20; i <= 32; i++) { // Example: show 20h (8 PM) â†’ 32h (8 AM next day)\r\n            const hour = i % 24\r\n            const label = hour.toString().padStart(2, '0') + \":00\"\r\n            axisX\r\n                .addCustomTick()\r\n                .setValue(i)\r\n                .setTickLength(4)\r\n                .setGridStrokeLength(0)\r\n                .setTextFormatter(() => label)\r\n                .setMarker((marker) =>\r\n                    marker.setTextFillStyle(new SolidFill({ color: ColorRGBA(170, 170, 170) }))\r\n                )\r\n        }\r\n\r\n        const figureHeight = 10\r\n        const figureThickness = 10\r\n        const figureGap = figureThickness * 0.5\r\n        const fitAxes = () => {\r\n            // Custom fitting for some additional margins\r\n            axisY.setInterval({ start: y, end: figureHeight * 0.5, stopAxisAfter: false })\r\n        }\r\n\r\n        let customYRange = figureHeight + figureGap * 1.6\r\n        const addCategory = (category) => {\r\n            const categoryY = y\r\n\r\n            const addSpan = (i, min, max, label) => {\r\n                // Add rect\r\n                const rectDimensions = {\r\n                    x: min,\r\n                    y: categoryY - figureHeight,\r\n                    width: max - min,\r\n                    height: figureHeight,\r\n                }\r\n                // Add element for span labels\r\n                // const spanText = chart\r\n                //     .addUIElement(UILayoutBuilders.Row, { x: axisX, y: axisY })\r\n                //     .setOrigin(UIOrigins.Center)\r\n                //     .setDraggingMode(UIDraggingModes.notDraggable)\r\n                //     .setPosition({\r\n                //         x: (min + max) / 2,\r\n                //         y: rectDimensions.y + 5,\r\n                //     })\r\n                //     .setBackground((background) => background.setFillStyle(emptyFill).setStrokeStyle(emptyLine))\r\n\r\n                // spanText.addElement(\r\n                //     UIElementBuilders.TextBox.addStyler((textBox) =>\r\n                //         textBox\r\n                //             .setTextFont((fontSettings) => fontSettings.setSize(13))\r\n                //             .setText(label)\r\n                //             .setTextFillStyle(new SolidFill().setColor(ColorRGBA(255, 255, 255))),\r\n                //     ),\r\n                // )\r\n                if (index !== i) {\r\n                    customYRange = customYRange + figureHeight + 1\r\n                }\r\n                fitAxes()\r\n                // Return figure\r\n                return chart.addRectangleSeries().add(rectDimensions).setCornerRadius(10)\r\n            }\r\n\r\n            // Add custom tick for category\r\n            axisY\r\n                .addCustomTick()\r\n                .setValue(y - figureHeight * 0.5)\r\n                .setGridStrokeLength(0)\r\n                .setTextFormatter((_) => category)\r\n                .setMarker((marker) => marker.setTextFillStyle(new SolidFill({ color: ColorRGBA(170, 170, 170) })))\r\n            y -= figureHeight * 1.5\r\n\r\n            fitAxes()\r\n            // Return interface for category\r\n            return {\r\n                addSpan,\r\n            }\r\n        }\r\n        // Return interface for span chart\r\n        return {\r\n            addCategory,\r\n        }\r\n      }\r\n\r\n    // Use the interface for example\r\n    let chart = spanChart()\r\n    const categories = ['Light', 'Deep', 'REM'].map((name) => chart.addCategory(name))\r\n    chart.categories = categories\r\n    chart.stageMap = {}\r\n    stages.forEach((stage, i) => {\r\n    chart.stageMap[stage] = i   // e.g. { light:0, deep:1, rem:2 }\r\n    })\r\n    const spans = []\r\n\r\n    let index = 0\r\n    spans.forEach((values, i) => {\r\n        values.forEach((value, j) => {\r\n            categories[i].addSpan(i, value[0], value[1])\r\n            // index = index + 1\r\n        })\r\n    })\r\n\r\n    setChart(chart);\r\n\r\n    return () => {\r\n      // Destroy the actual chart instance when component lifecycle ends\r\n      if (actualChart) {\r\n        actualChart.dispose();\r\n      }\r\n    };\r\n  }, [id, lc]); \r\n\r\n  // Update data whenever data prop changes\r\n  useEffect(() => {\r\n    if (!chart || !data) return\r\n    \r\n    console.log(`SpanChart update, data: `, data);\r\n\r\n    // Clear previous rectangles\r\n    if (chart.rectangles) {\r\n      chart.rectangles.forEach(rect => {\r\n        try {\r\n          rect.dispose();\r\n        } catch (e) {\r\n          // Rectangle might already be disposed\r\n        }\r\n      });\r\n      chart.rectangles = [];\r\n    }\r\n\r\n    data.forEach((entry) => {\r\n      const { stage, spans } = entry\r\n      if (stage === \"wake\") return // skip wake in chart\r\n\r\n      // find correct category row\r\n      const idx = chart.stageMap[stage]\r\n      if (idx === undefined) {\r\n        console.warn(\"Unknown stage:\", stage)\r\n        return\r\n      }\r\n\r\n      spans.forEach(span => {\r\n        const rect = chart.categories[idx].addSpan(idx, span[0], span[1])\r\n        chart.rectangles.push(rect)\r\n      })\r\n    })\r\n  }, [chart, data]);\r\n\r\n    // Whenever props.title changes, it is reapplied to existing chart without recreating it\r\n  useEffect(() => {\r\n    if (!chart) return\r\n    chart.setTitle(title)\r\n  }, [chart, title]);\r\n\r\n  return <div id={id} style={{ width: \"100%\", height: \"100%\" }}></div>;\r\n}"],"mappings":";;AAAA,SAASA,SAAS,EAAEC,SAAS,EAAEC,kBAAkB,EAAEC,MAAM,QAAQ,sBAAsB;AACvF,SAASC,SAAS,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,KAAK,QAAQ,OAAO;AAC9D,SAASC,SAAS,QAAQ,UAAU;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAErC,eAAe,SAASC,SAASA,CAACC,KAAK,EAAE;EAAAC,EAAA;EACvC,MAAMC,IAAI,GAAGF,KAAK,CAACE,IAAI;EACvB,MAAMC,KAAK,GAAGH,KAAK,CAACG,KAAK;EACzB;EACA,MAAMC,EAAE,GAAGT,KAAK,CAAC,CAAC;EAClB,MAAMU,EAAE,GAAGX,UAAU,CAACE,SAAS,CAAC;EAChC,MAAM,CAACU,KAAK,EAAEC,QAAQ,CAAC,GAAGd,QAAQ,CAACe,SAAS,CAAC;;EAE7C;EACAhB,SAAS,CAAC,MAAM;IACd,MAAMiB,SAAS,GAAGC,QAAQ,CAACC,cAAc,CAACP,EAAE,CAAC;IAC7C,IAAI,CAACK,SAAS,EAAE;IAChB,IAAI,CAACJ,EAAE,EAAE;MACPO,OAAO,CAACC,GAAG,CAAC,0BAA0B,CAAC;MACvC;IACF;IAEA,MAAMC,MAAM,GAAG,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC;;IAEvC;IACA,IAAIC,SAAS;IACb,IAAIC,WAAW,EAAC;IAChB;IACAD,SAAS,GAAGA,CAAA,KAAM;MACd;MACA,MAAMT,KAAK,GAAGD,EAAE,CAACY,OAAO,CAAC;QACjBC,MAAM,EAAE;UAAEC,OAAO,EAAE;QAAM,CAAC;QAC1BC,KAAK,EAAE7B,MAAM,CAAC8B,UAAU;QACxBZ;MACJ,CAAC,CAAC;MACFH,KAAK,CAACgB,QAAQ,CAAC,EAAE,CAAC,CACjBC,mBAAmB,CAACf,SAAS,CAAC,CAC9BgB,aAAa,CAAChB,SAAS,CAAC;;MAE7B;MACAQ,WAAW,GAAGV,KAAK;MAEnB,MAAMmB,KAAK,GAAGnB,KAAK,CACdoB,eAAe,CAAC;MACjB;MAAA,CACCC,eAAe,CAACrC,kBAAkB,CAACsC,KAAK,CAAC;MAE9C,MAAMC,KAAK,GAAGvB,KAAK,CACdwB,eAAe,CAAC;MACjB;MAAA,CACCH,eAAe,CAACrC,kBAAkB,CAACsC,KAAK,CAAC;MAE9C,IAAIG,CAAC,GAAG,CAAC;MACT,KAAK,IAAIC,CAAC,GAAG,EAAE,EAAEA,CAAC,IAAI,EAAE,EAAEA,CAAC,EAAE,EAAE;QAAE;QAC7B,MAAMC,IAAI,GAAGD,CAAC,GAAG,EAAE;QACnB,MAAME,KAAK,GAAGD,IAAI,CAACE,QAAQ,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,GAAG,KAAK;QACtDX,KAAK,CACAY,aAAa,CAAC,CAAC,CACfC,QAAQ,CAACN,CAAC,CAAC,CACXO,aAAa,CAAC,CAAC,CAAC,CAChBC,mBAAmB,CAAC,CAAC,CAAC,CACtBC,gBAAgB,CAAC,MAAMP,KAAK,CAAC,CAC7BQ,SAAS,CAAEC,MAAM,IACdA,MAAM,CAACC,gBAAgB,CAAC,IAAIxD,SAAS,CAAC;UAAEyD,KAAK,EAAExD,SAAS,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG;QAAE,CAAC,CAAC,CAC9E,CAAC;MACT;MAEA,MAAMyD,YAAY,GAAG,EAAE;MACvB,MAAMC,eAAe,GAAG,EAAE;MAC1B,MAAMC,SAAS,GAAGD,eAAe,GAAG,GAAG;MACvC,MAAME,OAAO,GAAGA,CAAA,KAAM;QAClB;QACApB,KAAK,CAACqB,WAAW,CAAC;UAAEC,KAAK,EAAEpB,CAAC;UAAEqB,GAAG,EAAEN,YAAY,GAAG,GAAG;UAAEO,aAAa,EAAE;QAAM,CAAC,CAAC;MAClF,CAAC;MAED,IAAIC,YAAY,GAAGR,YAAY,GAAGE,SAAS,GAAG,GAAG;MACjD,MAAMO,WAAW,GAAIC,QAAQ,IAAK;QAC9B,MAAMC,SAAS,GAAG1B,CAAC;QAEnB,MAAM2B,OAAO,GAAGA,CAAC1B,CAAC,EAAE2B,GAAG,EAAEC,GAAG,EAAE1B,KAAK,KAAK;UACpC;UACA,MAAM2B,cAAc,GAAG;YACnBC,CAAC,EAAEH,GAAG;YACN5B,CAAC,EAAE0B,SAAS,GAAGX,YAAY;YAC3BiB,KAAK,EAAEH,GAAG,GAAGD,GAAG;YAChBK,MAAM,EAAElB;UACZ,CAAC;UACD;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,IAAImB,KAAK,KAAKjC,CAAC,EAAE;YACbsB,YAAY,GAAGA,YAAY,GAAGR,YAAY,GAAG,CAAC;UAClD;UACAG,OAAO,CAAC,CAAC;UACT;UACA,OAAO3C,KAAK,CAAC4D,kBAAkB,CAAC,CAAC,CAACC,GAAG,CAACN,cAAc,CAAC,CAACO,eAAe,CAAC,EAAE,CAAC;QAC7E,CAAC;;QAED;QACAvC,KAAK,CACAQ,aAAa,CAAC,CAAC,CACfC,QAAQ,CAACP,CAAC,GAAGe,YAAY,GAAG,GAAG,CAAC,CAChCN,mBAAmB,CAAC,CAAC,CAAC,CACtBC,gBAAgB,CAAE4B,CAAC,IAAKb,QAAQ,CAAC,CACjCd,SAAS,CAAEC,MAAM,IAAKA,MAAM,CAACC,gBAAgB,CAAC,IAAIxD,SAAS,CAAC;UAAEyD,KAAK,EAAExD,SAAS,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG;QAAE,CAAC,CAAC,CAAC,CAAC;QACvG0C,CAAC,IAAIe,YAAY,GAAG,GAAG;QAEvBG,OAAO,CAAC,CAAC;QACT;QACA,OAAO;UACHS;QACJ,CAAC;MACL,CAAC;MACD;MACA,OAAO;QACHH;MACJ,CAAC;IACH,CAAC;;IAEH;IACA,IAAIjD,KAAK,GAAGS,SAAS,CAAC,CAAC;IACvB,MAAMuD,UAAU,GAAG,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC,CAACC,GAAG,CAAEC,IAAI,IAAKlE,KAAK,CAACiD,WAAW,CAACiB,IAAI,CAAC,CAAC;IAClFlE,KAAK,CAACgE,UAAU,GAAGA,UAAU;IAC7BhE,KAAK,CAACmE,QAAQ,GAAG,CAAC,CAAC;IACnB3D,MAAM,CAAC4D,OAAO,CAAC,CAACC,KAAK,EAAE3C,CAAC,KAAK;MAC7B1B,KAAK,CAACmE,QAAQ,CAACE,KAAK,CAAC,GAAG3C,CAAC,EAAG;IAC5B,CAAC,CAAC;IACF,MAAM4C,KAAK,GAAG,EAAE;IAEhB,IAAIX,KAAK,GAAG,CAAC;IACbW,KAAK,CAACF,OAAO,CAAC,CAACG,MAAM,EAAE7C,CAAC,KAAK;MACzB6C,MAAM,CAACH,OAAO,CAAC,CAACI,KAAK,EAAEC,CAAC,KAAK;QACzBT,UAAU,CAACtC,CAAC,CAAC,CAAC0B,OAAO,CAAC1B,CAAC,EAAE8C,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC;QAC5C;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;IAEFvE,QAAQ,CAACD,KAAK,CAAC;IAEf,OAAO,MAAM;MACX;MACA,IAAIU,WAAW,EAAE;QACfA,WAAW,CAACgE,OAAO,CAAC,CAAC;MACvB;IACF,CAAC;EACH,CAAC,EAAE,CAAC5E,EAAE,EAAEC,EAAE,CAAC,CAAC;;EAEZ;EACAb,SAAS,CAAC,MAAM;IACd,IAAI,CAACc,KAAK,IAAI,CAACJ,IAAI,EAAE;IAErBU,OAAO,CAACC,GAAG,CAAC,0BAA0B,EAAEX,IAAI,CAAC;;IAE7C;IACA,IAAII,KAAK,CAAC2E,UAAU,EAAE;MACpB3E,KAAK,CAAC2E,UAAU,CAACP,OAAO,CAACQ,IAAI,IAAI;QAC/B,IAAI;UACFA,IAAI,CAACF,OAAO,CAAC,CAAC;QAChB,CAAC,CAAC,OAAOG,CAAC,EAAE;UACV;QAAA;MAEJ,CAAC,CAAC;MACF7E,KAAK,CAAC2E,UAAU,GAAG,EAAE;IACvB;IAEA/E,IAAI,CAACwE,OAAO,CAAEU,KAAK,IAAK;MACtB,MAAM;QAAET,KAAK;QAAEC;MAAM,CAAC,GAAGQ,KAAK;MAC9B,IAAIT,KAAK,KAAK,MAAM,EAAE,OAAM,CAAC;;MAE7B;MACA,MAAMU,GAAG,GAAG/E,KAAK,CAACmE,QAAQ,CAACE,KAAK,CAAC;MACjC,IAAIU,GAAG,KAAK7E,SAAS,EAAE;QACrBI,OAAO,CAAC0E,IAAI,CAAC,gBAAgB,EAAEX,KAAK,CAAC;QACrC;MACF;MAEAC,KAAK,CAACF,OAAO,CAACa,IAAI,IAAI;QACpB,MAAML,IAAI,GAAG5E,KAAK,CAACgE,UAAU,CAACe,GAAG,CAAC,CAAC3B,OAAO,CAAC2B,GAAG,EAAEE,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;QACjEjF,KAAK,CAAC2E,UAAU,CAACO,IAAI,CAACN,IAAI,CAAC;MAC7B,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,EAAE,CAAC5E,KAAK,EAAEJ,IAAI,CAAC,CAAC;;EAEf;EACFV,SAAS,CAAC,MAAM;IACd,IAAI,CAACc,KAAK,EAAE;IACZA,KAAK,CAACgB,QAAQ,CAACnB,KAAK,CAAC;EACvB,CAAC,EAAE,CAACG,KAAK,EAAEH,KAAK,CAAC,CAAC;EAElB,oBAAOL,OAAA;IAAKM,EAAE,EAAEA,EAAG;IAACqF,KAAK,EAAE;MAAE1B,KAAK,EAAE,MAAM;MAAEC,MAAM,EAAE;IAAO;EAAE;IAAA0B,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAM,CAAC;AACtE;AAAC5F,EAAA,CAzMuBF,SAAS;EAAA,QAIpBJ,KAAK;AAAA;AAAAmG,EAAA,GAJM/F,SAAS;AAAA,IAAA+F,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}