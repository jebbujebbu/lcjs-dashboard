{"ast":null,"code":"// utils/toChartSpans.js\nexport default function toChartSpans(levels) {\n  console.log(`toChartSpans, props: ${levels}`);\n  if (!Array.isArray(levels) || levels.length === 0) {\n    return []; // nothing to render\n  }\n  const stageOrder = [\"light\", \"deep\", \"rem\"];\n  const grouped = {\n    light: [],\n    deep: [],\n    rem: []\n  };\n\n  // Use the first entry as reference date\n  const refDate = new Date(levels[0].start);\n  let prevStage = null;\n  let currentSpan = null;\n  levels.forEach(l => {\n    if (!l || !l.stage || !l.start || !l.end) return;\n    const start = parseTimeToHourFraction(l.start, refDate);\n    const end = parseTimeToHourFraction(l.end, refDate);\n    if (l.stage === \"wake\") {\n      // bridge: extend previous stage to cover the gap, if any\n      if (currentSpan) {\n        currentSpan[1] = end; // stretch end to after wake\n      }\n      return;\n    }\n    if (l.stage === prevStage && currentSpan) {\n      // same stage continues -> merge into previous span\n      currentSpan[1] = end;\n    } else {\n      // push new span\n      currentSpan = [start, end];\n      grouped[l.stage].push(currentSpan);\n    }\n    prevStage = l.stage;\n  });\n  return stageOrder.map(stage => ({\n    stage,\n    spans: grouped[stage]\n  }));\n}\nfunction parseTimeToHourFraction(timeStr, referenceDate) {\n  if (!timeStr) return 0;\n  const d = new Date(timeStr);\n\n  // Absolute hour of the day\n  let hours = d.getHours() + d.getMinutes() / 60;\n\n  // Add day offset (0 for same day, 24 if next day, etc.)\n  const dayOffset = Math.floor((d - referenceDate) / (1000 * 60 * 60 * 24));\n  hours += dayOffset * 24;\n\n  // Align to chart axis: keep values in [20, 32]\n  if (hours < 20) {\n    hours += 24; // e.g. 00:30 → 24.5\n  }\n  return hours;\n}","map":{"version":3,"names":["toChartSpans","levels","console","log","Array","isArray","length","stageOrder","grouped","light","deep","rem","refDate","Date","start","prevStage","currentSpan","forEach","l","stage","end","parseTimeToHourFraction","push","map","spans","timeStr","referenceDate","d","hours","getHours","getMinutes","dayOffset","Math","floor"],"sources":["D:/Repos/lcjs-dashboard/frontend/src/utils/toChartSpans.js"],"sourcesContent":["// utils/toChartSpans.js\r\nexport default function toChartSpans(levels) {\r\n  console.log(`toChartSpans, props: ${levels}`);\r\n\r\n  if (!Array.isArray(levels) || levels.length === 0) {\r\n    return []   // nothing to render\r\n  }\r\n\r\n  const stageOrder = [\"light\", \"deep\", \"rem\"];\r\n  const grouped = { light: [], deep: [], rem: [] };\r\n\r\n  // Use the first entry as reference date\r\n  const refDate = new Date(levels[0].start);\r\n\r\n  let prevStage = null;\r\n  let currentSpan = null;\r\n\r\n  levels.forEach(l => {\r\n    if (!l || !l.stage || !l.start || !l.end) return;\r\n\r\n    const start = parseTimeToHourFraction(l.start, refDate);\r\n    const end = parseTimeToHourFraction(l.end, refDate);\r\n\r\n    if (l.stage === \"wake\") {\r\n      // bridge: extend previous stage to cover the gap, if any\r\n      if (currentSpan) {\r\n        currentSpan[1] = end; // stretch end to after wake\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (l.stage === prevStage && currentSpan) {\r\n      // same stage continues -> merge into previous span\r\n      currentSpan[1] = end;\r\n    } else {\r\n      // push new span\r\n      currentSpan = [start, end];\r\n      grouped[l.stage].push(currentSpan);\r\n    }\r\n\r\n    prevStage = l.stage;\r\n  });\r\n\r\n  return stageOrder.map(stage => ({ stage, spans: grouped[stage] }));\r\n}\r\n\r\nfunction parseTimeToHourFraction(timeStr, referenceDate) {\r\n  if (!timeStr) return 0;\r\n  const d = new Date(timeStr);\r\n\r\n  // Absolute hour of the day\r\n  let hours = d.getHours() + d.getMinutes() / 60;\r\n\r\n  // Add day offset (0 for same day, 24 if next day, etc.)\r\n  const dayOffset = Math.floor((d - referenceDate) / (1000 * 60 * 60 * 24));\r\n  hours += dayOffset * 24;\r\n\r\n  // Align to chart axis: keep values in [20, 32]\r\n  if (hours < 20) {\r\n    hours += 24; // e.g. 00:30 → 24.5\r\n  }\r\n\r\n  return hours;\r\n}\r\n"],"mappings":"AAAA;AACA,eAAe,SAASA,YAAYA,CAACC,MAAM,EAAE;EAC3CC,OAAO,CAACC,GAAG,CAAC,wBAAwBF,MAAM,EAAE,CAAC;EAE7C,IAAI,CAACG,KAAK,CAACC,OAAO,CAACJ,MAAM,CAAC,IAAIA,MAAM,CAACK,MAAM,KAAK,CAAC,EAAE;IACjD,OAAO,EAAE,EAAG;EACd;EAEA,MAAMC,UAAU,GAAG,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC;EAC3C,MAAMC,OAAO,GAAG;IAAEC,KAAK,EAAE,EAAE;IAAEC,IAAI,EAAE,EAAE;IAAEC,GAAG,EAAE;EAAG,CAAC;;EAEhD;EACA,MAAMC,OAAO,GAAG,IAAIC,IAAI,CAACZ,MAAM,CAAC,CAAC,CAAC,CAACa,KAAK,CAAC;EAEzC,IAAIC,SAAS,GAAG,IAAI;EACpB,IAAIC,WAAW,GAAG,IAAI;EAEtBf,MAAM,CAACgB,OAAO,CAACC,CAAC,IAAI;IAClB,IAAI,CAACA,CAAC,IAAI,CAACA,CAAC,CAACC,KAAK,IAAI,CAACD,CAAC,CAACJ,KAAK,IAAI,CAACI,CAAC,CAACE,GAAG,EAAE;IAE1C,MAAMN,KAAK,GAAGO,uBAAuB,CAACH,CAAC,CAACJ,KAAK,EAAEF,OAAO,CAAC;IACvD,MAAMQ,GAAG,GAAGC,uBAAuB,CAACH,CAAC,CAACE,GAAG,EAAER,OAAO,CAAC;IAEnD,IAAIM,CAAC,CAACC,KAAK,KAAK,MAAM,EAAE;MACtB;MACA,IAAIH,WAAW,EAAE;QACfA,WAAW,CAAC,CAAC,CAAC,GAAGI,GAAG,CAAC,CAAC;MACxB;MACA;IACF;IAEA,IAAIF,CAAC,CAACC,KAAK,KAAKJ,SAAS,IAAIC,WAAW,EAAE;MACxC;MACAA,WAAW,CAAC,CAAC,CAAC,GAAGI,GAAG;IACtB,CAAC,MAAM;MACL;MACAJ,WAAW,GAAG,CAACF,KAAK,EAAEM,GAAG,CAAC;MAC1BZ,OAAO,CAACU,CAAC,CAACC,KAAK,CAAC,CAACG,IAAI,CAACN,WAAW,CAAC;IACpC;IAEAD,SAAS,GAAGG,CAAC,CAACC,KAAK;EACrB,CAAC,CAAC;EAEF,OAAOZ,UAAU,CAACgB,GAAG,CAACJ,KAAK,KAAK;IAAEA,KAAK;IAAEK,KAAK,EAAEhB,OAAO,CAACW,KAAK;EAAE,CAAC,CAAC,CAAC;AACpE;AAEA,SAASE,uBAAuBA,CAACI,OAAO,EAAEC,aAAa,EAAE;EACvD,IAAI,CAACD,OAAO,EAAE,OAAO,CAAC;EACtB,MAAME,CAAC,GAAG,IAAId,IAAI,CAACY,OAAO,CAAC;;EAE3B;EACA,IAAIG,KAAK,GAAGD,CAAC,CAACE,QAAQ,CAAC,CAAC,GAAGF,CAAC,CAACG,UAAU,CAAC,CAAC,GAAG,EAAE;;EAE9C;EACA,MAAMC,SAAS,GAAGC,IAAI,CAACC,KAAK,CAAC,CAACN,CAAC,GAAGD,aAAa,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;EACzEE,KAAK,IAAIG,SAAS,GAAG,EAAE;;EAEvB;EACA,IAAIH,KAAK,GAAG,EAAE,EAAE;IACdA,KAAK,IAAI,EAAE,CAAC,CAAC;EACf;EAEA,OAAOA,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}