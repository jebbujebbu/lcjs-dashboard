{"ast":null,"code":"var _jsxFileName = \"D:\\\\Repos\\\\lcjs-dashboard\\\\frontend\\\\src\\\\components\\\\charts\\\\MosaicChart.jsx\",\n  _s = $RefreshSig$();\nimport { SolidFill, ColorHEX, ColorRGBA, emptyLine, emptyFill, UIElementBuilders, UIBackgrounds, UIOrigins, AxisTickStrategies, Themes } from \"@lightningchart/lcjs\";\nimport { useEffect, useState, useContext, useId } from \"react\";\nimport { LCContext } from \"../../LC\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function MosaicChart(props) {\n  _s();\n  const data = props.data;\n  //   console.log('MosaicChart data', data);\n  const id = useId();\n  const lc = useContext(LCContext);\n  const [chart, setChart] = useState(undefined);\n\n  // Create chart just once during lifecycle of component.\n  useEffect(() => {\n    const container = document.getElementById(id);\n    if (!container) return;\n    if (!lc) {\n      console.log(\"LC context not ready yet\");\n      return;\n    }\n\n    // Define an interface for creating mosaic charts.\n    let mosaicChart;\n    let chartInstance; // Store the actual chart instance\n    // User side MosaicChart logic.\n    mosaicChart = () => {\n      // Create a XY-Chart and add a RectSeries to it for rendering rectangles.\n      const chart = lc.ChartXY({\n        legend: {\n          visible: false\n        },\n        theme: Themes.cyberSpace,\n        container\n      }).setTitle('Weekly Activity').setUserInteractions(undefined).setCursorMode(undefined);\n      chartInstance = chart; // Store the chart instance\n      const rectangles = chart.addRectangleSeries();\n      const bottomAxis = chart.getDefaultAxisX().setInterval({\n        start: 0,\n        end: 100,\n        stopAxisAfter: false\n      }).setScrollStrategy(undefined).setTitle('').setTickStrategy(AxisTickStrategies.Empty);\n      const leftAxis = chart.getDefaultAxisY().setInterval({\n        start: 0,\n        end: 100,\n        stopAxisAfter: false\n      })\n      // Hide default ticks of left Axis.\n      .setTickStrategy(AxisTickStrategies.Empty);\n      const rightAxis = chart.addAxisY({\n        opposite: true\n      }).setInterval({\n        start: 0,\n        end: 100,\n        stopAxisAfter: false\n      }).setScrollStrategy(undefined).setTitle('%');\n      const topAxis = chart.addAxisX({\n        opposite: true\n      }).setInterval({\n        start: 0,\n        end: 100,\n        stopAxisAfter: false\n      })\n      // Hide default ticks of top Axis.\n      .setTickStrategy(AxisTickStrategies.Empty);\n\n      // Create marker for the top of each column.\n      const categoryMarkerBuilder = UIElementBuilders.AxisTickMajor;\n      // Create text on top of each section.\n      const subCategoryLabelBuilder = UIElementBuilders.TextBox\n      // Style the label.\n      .addStyler(label => label\n      // Set the origin point and fillStyle (color) for the label.\n      .setOrigin(UIOrigins.Center).setTextFillStyle(new SolidFill().setColor(ColorRGBA(255, 255, 255))).setPointerEvents(false).setBackground(background => background.setFillStyle(emptyFill).setStrokeStyle(emptyLine)));\n      const categories = [];\n      const yCategories = [];\n      const subCategories = [];\n      let margin = 0.1;\n\n      // Recreate rectangle figures from scratch.\n      const _updateChart = () => {\n        // Remove already existing figures.\n        rectangles.clear();\n        // Make new figures from each category.\n        const sumCategoryValues = categories.reduce((prev, cur) => prev + cur.value, 0);\n        if (sumCategoryValues > 0) {\n          let xPos = 0;\n          // For each category on a single column, recreate the marker to the left of the chart.\n          for (const yCategory of yCategories) {\n            yCategory.tick.setTextFormatter(_ => yCategory.name).setValue(yCategory.value).setMarkerVisible(true);\n          }\n          // For each category (or column)\n          for (const category of categories) {\n            // Calculate the correct value to display for each category\n            const relativeCategoryValue = 100 * category.value / sumCategoryValues;\n            const sumSubCategoryValues = category.subCategories.reduce((prev, cur) => prev + cur.value, 0);\n            // If there are subCategories for the column\n            if (sumSubCategoryValues > 0) {\n              // Recreate the tick to display above each category and set the correct value to it\n              category.tick.setTextFormatter(_ => category.name).setValue(xPos + relativeCategoryValue / 2).setMarkerVisible(true);\n              let yPos = 0;\n              for (const subCategory of category.subCategories) {\n                // Calculate proper value for the subCategory\n                const relativeSubCategoryValue = 100 * subCategory.value / sumSubCategoryValues;\n                if (relativeSubCategoryValue > 0) {\n                  const rectangleDimensions = {\n                    x: xPos + margin,\n                    y: yPos + margin,\n                    width: relativeCategoryValue - 2 * margin,\n                    height: relativeSubCategoryValue - 2 * margin\n                  };\n                  // Create a rectangle to represent the subCategory\n                  rectangles.add(rectangleDimensions).setFillStyle(subCategory.subCategory.fillStyle).setStrokeStyle(emptyLine);\n                  // Recreate the label for the subCategory and update the value for it\n                  subCategory.label.setText(Math.round(relativeSubCategoryValue) + '%').setPosition({\n                    x: xPos + relativeCategoryValue / 2,\n                    y: yPos + relativeSubCategoryValue / 2\n                  }).setVisible(true);\n                }\n                // The subCategory is not shown, so we can dispose of its label.\n                else subCategory.label.setVisible(false);\n                yPos += relativeSubCategoryValue;\n              }\n            } else {\n              // There are no subCategories for the column, so the elements related to it can be disposed.\n              category.tick.setMarkerVisible(false);\n              category.subCategories.forEach(sub => sub.label.setVisible(false));\n            }\n            xPos += relativeCategoryValue;\n          }\n        }\n      };\n      // Method to add a new subCategory to the chart.\n      const addSubCategory = () => {\n        const subCategory = {\n          fillStyle: Themes.cyberSpace.seriesFillStyle,\n          setFillStyle(fillStyle) {\n            this.fillStyle = fillStyle;\n            // Refresh the chart.\n            _updateChart();\n            return this;\n          }\n        };\n        subCategories.push(subCategory);\n        return subCategory;\n      };\n      // Method to add a new main category to the chart.\n      const addCategory = name => {\n        const category = {\n          name,\n          value: 0,\n          tick: topAxis.addCustomTick(categoryMarkerBuilder).setGridStrokeStyle(emptyLine),\n          subCategories: [],\n          setCategoryValue(value) {\n            this.value = value;\n            _updateChart();\n            return this;\n          },\n          setSubCategoryValue(subCategory, value) {\n            const existing = this.subCategories.find(a => a.subCategory == subCategory);\n            if (existing !== undefined) {\n              existing.value = value;\n            } else {\n              this.subCategories.push({\n                subCategory,\n                value,\n                label: chart.addUIElement(subCategoryLabelBuilder, {\n                  x: bottomAxis,\n                  y: rightAxis\n                })\n              });\n            }\n            _updateChart();\n            return this;\n          }\n        };\n        categories.push(category);\n        return category;\n      };\n      // Method to add subCategory markers.\n      const addYCategory = (name, value) => {\n        const yCategory = {\n          name,\n          value: value,\n          tick: leftAxis.addCustomTick(categoryMarkerBuilder).setGridStrokeStyle(emptyLine),\n          setCategoryYValue(value) {\n            this.value = value;\n            _updateChart();\n            return this;\n          }\n        };\n        yCategories.push(yCategory);\n        return yCategory;\n      };\n      // Method to clear all categories\n      const clearCategories = () => {\n        // Dispose of all category ticks and subcategory labels properly\n        categories.forEach(category => {\n          category.tick.dispose(); // Built-in dispose method\n          // Dispose of all subcategory labels\n          category.subCategories.forEach(sub => {\n            sub.label.dispose(); // Built-in dispose method\n          });\n        });\n        // Clear the arrays\n        categories.length = 0;\n        // Clear rectangles using built-in method\n        rectangles.clear();\n      };\n      // Return interface for mosaic chart\n      return {\n        addSubCategory,\n        addCategory,\n        addYCategory,\n        clearCategories\n      };\n    };\n\n    // Create the mosaic chart interface\n    const mosaicChartInterface = mosaicChart();\n    mosaicChartInterface.addYCategory('High', 80);\n    mosaicChartInterface.addYCategory('Medium', 50);\n    mosaicChartInterface.addYCategory('Low', 20);\n\n    // Create subcategories for activity levels\n    const subCategory_low = mosaicChartInterface.addSubCategory().setFillStyle(new SolidFill().setColor(ColorHEX(\"#d2a25fff\")));\n    const subCategory_medium = mosaicChartInterface.addSubCategory().setFillStyle(new SolidFill().setColor(ColorHEX(\"#e168e5ff\")));\n    const subCategory_high = mosaicChartInterface.addSubCategory().setFillStyle(new SolidFill().setColor(ColorHEX(\"#8386dfff\")));\n    setChart({\n      interface: mosaicChartInterface,\n      subcategories: {\n        low: subCategory_low,\n        medium: subCategory_medium,\n        high: subCategory_high\n      },\n      instance: chartInstance // Store the chart instance in state\n    });\n    return () => {\n      // Destroy the actual LightningChart instance when component lifecycle ends\n      if (chartInstance && chartInstance.dispose) {\n        chartInstance.dispose();\n      }\n    };\n  }, [id, lc]);\n\n  // Update line series data whenever data prop changes.\n  useEffect(() => {\n    if (!chart || !data) return;\n\n    // console.log(\"Mosaic chart updating with data:\", data);\n\n    // Use existing chart interface and subcategories\n    const {\n      interface: mosaicChart,\n      subcategories\n    } = chart;\n\n    // Clear existing categories\n    mosaicChart.clearCategories();\n\n    // Add categories for each day and set their values\n    for (let i = 0; i < data.length; i++) {\n      //   console.log(`Adding Day ${i} data:`, data[i]);\n\n      mosaicChart.addCategory(data[i].date).setCategoryValue(100 / data.length).setSubCategoryValue(subcategories.low, data[i].low).setSubCategoryValue(subcategories.medium, data[i].medium).setSubCategoryValue(subcategories.high, data[i].high);\n    }\n  }, [chart, data]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    id: id,\n    style: {\n      width: \"100%\",\n      height: \"100%\"\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 284,\n    columnNumber: 12\n  }, this);\n}\n_s(MosaicChart, \"lPoGF9T2AB4o0eYXL6tWsHPot3c=\", false, function () {\n  return [useId];\n});\n_c = MosaicChart;\nvar _c;\n$RefreshReg$(_c, \"MosaicChart\");","map":{"version":3,"names":["SolidFill","ColorHEX","ColorRGBA","emptyLine","emptyFill","UIElementBuilders","UIBackgrounds","UIOrigins","AxisTickStrategies","Themes","useEffect","useState","useContext","useId","LCContext","jsxDEV","_jsxDEV","MosaicChart","props","_s","data","id","lc","chart","setChart","undefined","container","document","getElementById","console","log","mosaicChart","chartInstance","ChartXY","legend","visible","theme","cyberSpace","setTitle","setUserInteractions","setCursorMode","rectangles","addRectangleSeries","bottomAxis","getDefaultAxisX","setInterval","start","end","stopAxisAfter","setScrollStrategy","setTickStrategy","Empty","leftAxis","getDefaultAxisY","rightAxis","addAxisY","opposite","topAxis","addAxisX","categoryMarkerBuilder","AxisTickMajor","subCategoryLabelBuilder","TextBox","addStyler","label","setOrigin","Center","setTextFillStyle","setColor","setPointerEvents","setBackground","background","setFillStyle","setStrokeStyle","categories","yCategories","subCategories","margin","_updateChart","clear","sumCategoryValues","reduce","prev","cur","value","xPos","yCategory","tick","setTextFormatter","_","name","setValue","setMarkerVisible","category","relativeCategoryValue","sumSubCategoryValues","yPos","subCategory","relativeSubCategoryValue","rectangleDimensions","x","y","width","height","add","fillStyle","setText","Math","round","setPosition","setVisible","forEach","sub","addSubCategory","seriesFillStyle","push","addCategory","addCustomTick","setGridStrokeStyle","setCategoryValue","setSubCategoryValue","existing","find","a","addUIElement","addYCategory","setCategoryYValue","clearCategories","dispose","length","mosaicChartInterface","subCategory_low","subCategory_medium","subCategory_high","interface","subcategories","low","medium","high","instance","i","date","style","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/Repos/lcjs-dashboard/frontend/src/components/charts/MosaicChart.jsx"],"sourcesContent":["import { SolidFill, ColorHEX, ColorRGBA, emptyLine, emptyFill, UIElementBuilders, UIBackgrounds, UIOrigins, AxisTickStrategies, Themes } from \"@lightningchart/lcjs\";\r\nimport { useEffect, useState, useContext, useId } from \"react\";\r\nimport { LCContext } from \"../../LC\";\r\n\r\nexport default function MosaicChart(props) {\r\n  const data = props.data;\r\n//   console.log('MosaicChart data', data);\r\n  const id = useId();\r\n  const lc = useContext(LCContext);\r\n  const [chart, setChart] = useState(undefined);\r\n\r\n  // Create chart just once during lifecycle of component.\r\n  useEffect(() => {\r\n    const container = document.getElementById(id);\r\n    if (!container) return\r\n    if (!lc) {\r\n      console.log(\"LC context not ready yet\");\r\n      return\r\n    }\r\n\r\n    // Define an interface for creating mosaic charts.\r\n    let mosaicChart\r\n    let chartInstance // Store the actual chart instance\r\n    // User side MosaicChart logic.\r\n    mosaicChart = () => {\r\n        // Create a XY-Chart and add a RectSeries to it for rendering rectangles.\r\n        const chart = lc\r\n            .ChartXY({\r\n                legend: { visible: false },\r\n                theme: Themes.cyberSpace,\r\n                container,\r\n            })\r\n            .setTitle('Weekly Activity')\r\n            .setUserInteractions(undefined)\r\n            .setCursorMode(undefined)\r\n        \r\n        chartInstance = chart // Store the chart instance\r\n        const rectangles = chart.addRectangleSeries()\r\n\r\n        const bottomAxis = chart\r\n            .getDefaultAxisX()\r\n            .setInterval({ start: 0, end: 100, stopAxisAfter: false })\r\n            .setScrollStrategy(undefined)\r\n            .setTitle('')\r\n            .setTickStrategy(AxisTickStrategies.Empty)\r\n        const leftAxis = chart\r\n            .getDefaultAxisY()\r\n            .setInterval({ start: 0, end: 100, stopAxisAfter: false })\r\n            // Hide default ticks of left Axis.\r\n            .setTickStrategy(AxisTickStrategies.Empty)\r\n        const rightAxis = chart\r\n            .addAxisY({ opposite: true })\r\n            .setInterval({ start: 0, end: 100, stopAxisAfter: false })\r\n            .setScrollStrategy(undefined)\r\n            .setTitle('%')\r\n        const topAxis = chart\r\n            .addAxisX({ opposite: true })\r\n            .setInterval({ start: 0, end: 100, stopAxisAfter: false })\r\n            // Hide default ticks of top Axis.\r\n            .setTickStrategy(AxisTickStrategies.Empty)\r\n\r\n        // Create marker for the top of each column.\r\n        const categoryMarkerBuilder = UIElementBuilders.AxisTickMajor\r\n        // Create text on top of each section.\r\n        const subCategoryLabelBuilder = UIElementBuilders.TextBox\r\n            // Style the label.\r\n            .addStyler((label) =>\r\n                label\r\n                    // Set the origin point and fillStyle (color) for the label.\r\n                    .setOrigin(UIOrigins.Center)\r\n                    .setTextFillStyle(new SolidFill().setColor(ColorRGBA(255, 255, 255)))\r\n                    .setPointerEvents(false)\r\n                    .setBackground((background) => background.setFillStyle(emptyFill).setStrokeStyle(emptyLine)),\r\n            )\r\n\r\n        const categories = []\r\n        const yCategories = []\r\n        const subCategories = []\r\n        let margin = 0.1\r\n\r\n        // Recreate rectangle figures from scratch.\r\n        const _updateChart = () => {\r\n            // Remove already existing figures.\r\n            rectangles.clear()\r\n            // Make new figures from each category.\r\n            const sumCategoryValues = categories.reduce((prev, cur) => prev + cur.value, 0)\r\n            if (sumCategoryValues > 0) {\r\n                let xPos = 0\r\n                // For each category on a single column, recreate the marker to the left of the chart.\r\n                for (const yCategory of yCategories) {\r\n                    yCategory.tick\r\n                        .setTextFormatter((_) => yCategory.name)\r\n                        .setValue(yCategory.value)\r\n                        .setMarkerVisible(true)\r\n                }\r\n                // For each category (or column)\r\n                for (const category of categories) {\r\n                    // Calculate the correct value to display for each category\r\n                    const relativeCategoryValue = (100 * category.value) / sumCategoryValues\r\n                    const sumSubCategoryValues = category.subCategories.reduce((prev, cur) => prev + cur.value, 0)\r\n                    // If there are subCategories for the column\r\n                    if (sumSubCategoryValues > 0) {\r\n                        // Recreate the tick to display above each category and set the correct value to it\r\n                        category.tick\r\n                            .setTextFormatter((_) => category.name)\r\n                            .setValue(xPos + relativeCategoryValue / 2)\r\n                            .setMarkerVisible(true)\r\n                        let yPos = 0\r\n                        for (const subCategory of category.subCategories) {\r\n                            // Calculate proper value for the subCategory\r\n                            const relativeSubCategoryValue = (100 * subCategory.value) / sumSubCategoryValues\r\n                            if (relativeSubCategoryValue > 0) {\r\n                                const rectangleDimensions = {\r\n                                    x: xPos + margin,\r\n                                    y: yPos + margin,\r\n                                    width: relativeCategoryValue - 2 * margin,\r\n                                    height: relativeSubCategoryValue - 2 * margin,\r\n                                }\r\n                                // Create a rectangle to represent the subCategory\r\n                                rectangles\r\n                                    .add(rectangleDimensions)\r\n                                    .setFillStyle(subCategory.subCategory.fillStyle)\r\n                                    .setStrokeStyle(emptyLine)\r\n                                // Recreate the label for the subCategory and update the value for it\r\n                                subCategory.label\r\n                                    .setText(Math.round(relativeSubCategoryValue) + '%')\r\n                                    .setPosition({\r\n                                        x: xPos + relativeCategoryValue / 2,\r\n                                        y: yPos + relativeSubCategoryValue / 2,\r\n                                    })\r\n                                    .setVisible(true)\r\n                            }\r\n                            // The subCategory is not shown, so we can dispose of its label.\r\n                            else subCategory.label.setVisible(false)\r\n                            yPos += relativeSubCategoryValue\r\n                        }\r\n                    } else {\r\n                        // There are no subCategories for the column, so the elements related to it can be disposed.\r\n                        category.tick.setMarkerVisible(false)\r\n                        category.subCategories.forEach((sub) => sub.label.setVisible(false))\r\n                    }\r\n                    xPos += relativeCategoryValue\r\n                }\r\n            }\r\n        }\r\n        // Method to add a new subCategory to the chart.\r\n        const addSubCategory = () => {\r\n            const subCategory = {\r\n                fillStyle: Themes.cyberSpace.seriesFillStyle,\r\n                setFillStyle(fillStyle) {\r\n                    this.fillStyle = fillStyle\r\n                    // Refresh the chart.\r\n                    _updateChart()\r\n                    return this\r\n                },\r\n            }\r\n            subCategories.push(subCategory)\r\n            return subCategory\r\n        }\r\n        // Method to add a new main category to the chart.\r\n        const addCategory = (name) => {\r\n            const category = {\r\n                name,\r\n                value: 0,\r\n                tick: topAxis.addCustomTick(categoryMarkerBuilder).setGridStrokeStyle(emptyLine),\r\n                subCategories: [],\r\n                setCategoryValue(value) {\r\n                    this.value = value\r\n                    _updateChart()\r\n                    return this\r\n                },\r\n                setSubCategoryValue(subCategory, value) {\r\n                    const existing = this.subCategories.find((a) => a.subCategory == subCategory)\r\n                    if (existing !== undefined) {\r\n                        existing.value = value\r\n                    } else {\r\n                        this.subCategories.push({\r\n                            subCategory,\r\n                            value,\r\n                            label: chart.addUIElement(subCategoryLabelBuilder, {\r\n                                x: bottomAxis,\r\n                                y: rightAxis,\r\n                            }),\r\n                        })\r\n                    }\r\n                    _updateChart()\r\n                    return this\r\n                },\r\n            }\r\n            categories.push(category)\r\n            return category\r\n        }\r\n        // Method to add subCategory markers.\r\n        const addYCategory = (name, value) => {\r\n            const yCategory = {\r\n                name,\r\n                value: value,\r\n                tick: leftAxis.addCustomTick(categoryMarkerBuilder).setGridStrokeStyle(emptyLine),\r\n                setCategoryYValue(value) {\r\n                    this.value = value\r\n                    _updateChart()\r\n                    return this\r\n                },\r\n            }\r\n            yCategories.push(yCategory)\r\n            return yCategory\r\n        }\r\n        // Method to clear all categories\r\n        const clearCategories = () => {\r\n            // Dispose of all category ticks and subcategory labels properly\r\n            categories.forEach(category => {\r\n                category.tick.dispose() // Built-in dispose method\r\n                // Dispose of all subcategory labels\r\n                category.subCategories.forEach(sub => {\r\n                    sub.label.dispose() // Built-in dispose method\r\n                })\r\n            })\r\n            // Clear the arrays\r\n            categories.length = 0\r\n            // Clear rectangles using built-in method\r\n            rectangles.clear()\r\n        }\r\n        // Return interface for mosaic chart\r\n        return {\r\n            addSubCategory,\r\n            addCategory,\r\n            addYCategory,\r\n            clearCategories,\r\n        }\r\n    }\r\n\r\n    // Create the mosaic chart interface\r\n    const mosaicChartInterface = mosaicChart()\r\n\r\n    mosaicChartInterface.addYCategory('High', 80)\r\n    mosaicChartInterface.addYCategory('Medium', 50)\r\n    mosaicChartInterface.addYCategory('Low', 20)\r\n\r\n    // Create subcategories for activity levels\r\n    const subCategory_low = mosaicChartInterface.addSubCategory().setFillStyle(new SolidFill().setColor(ColorHEX(\"#d2a25fff\")))\r\n    const subCategory_medium = mosaicChartInterface.addSubCategory().setFillStyle(new SolidFill().setColor(ColorHEX(\"#e168e5ff\")))\r\n    const subCategory_high = mosaicChartInterface.addSubCategory().setFillStyle(new SolidFill().setColor(ColorHEX(\"#8386dfff\")))\r\n\r\n    setChart({\r\n      interface: mosaicChartInterface,\r\n      subcategories: { low: subCategory_low, medium: subCategory_medium, high: subCategory_high },\r\n      instance: chartInstance // Store the chart instance in state\r\n    });\r\n\r\n    return () => {\r\n      // Destroy the actual LightningChart instance when component lifecycle ends\r\n      if (chartInstance && chartInstance.dispose) {\r\n        chartInstance.dispose();\r\n      }\r\n    };\r\n  }, [id, lc]);\r\n\r\n\r\n  // Update line series data whenever data prop changes.\r\n  useEffect(() => {\r\n    if (!chart || !data) return\r\n    \r\n    // console.log(\"Mosaic chart updating with data:\", data);\r\n    \r\n    // Use existing chart interface and subcategories\r\n    const { interface: mosaicChart, subcategories } = chart;\r\n    \r\n    // Clear existing categories\r\n    mosaicChart.clearCategories();\r\n    \r\n    // Add categories for each day and set their values\r\n    for (let i = 0; i < data.length; i++) {\r\n    //   console.log(`Adding Day ${i} data:`, data[i]);\r\n      \r\n      mosaicChart\r\n        .addCategory(data[i].date)\r\n        .setCategoryValue(100 / data.length)\r\n        .setSubCategoryValue(subcategories.low, data[i].low)\r\n        .setSubCategoryValue(subcategories.medium, data[i].medium)\r\n        .setSubCategoryValue(subcategories.high, data[i].high);\r\n    }\r\n  }, [chart, data]);\r\n\r\n    return <div id={id} style={{ width: \"100%\", height: \"100%\" }}></div>;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}